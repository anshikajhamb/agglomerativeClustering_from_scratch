# -*- coding: utf-8 -*-
"""Anshika_Bhavi_ReeyaLab1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10HV1ULP15e76ngraFQWvDD-BzkegAX5u

This code was written by:

Anshika Jhamb

Bhavi Kapadia

#Implementing Agglomerative Clustering

Importing the necessary packages.
"""

#importing necessary packages
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt 
from google.colab import files 
import math 
from operator import indexOf

"""Uploading the data."""

#using the upload function to upload the data
uploaded = files.upload()

#reading the uploaded data as ourData
ourData = pd.read_csv('dataset - Sheet1.csv') #upload our csv file here

"""Putting our Data into a matrix containing two columns for features and rows for each point."""

#extracting 2 features from our dataset. check if data needs to be scaled.
Data = ourData.iloc[:50, [0,1]].values 
#initial number of clusters
InitClusters = len(Data) 
print('Initial Number of points/clusters: ',InitClusters)

"""Visualising the data and all the points:"""

#making lists to store the x and y axes values of the points
x = []
y = []
for i in Data:
      x.append(i[0])
      y.append(i[1])
points = len(Data)
Title = 'Data to be clustered with '+str(points)+' points.'

#plotting the data
plt.figure(figsize=(6.5,6))
plt.scatter(x, y)
plt.xticks(range(0,101,10))
plt.yticks(range(0,101,10))
plt.title(Title);

"""Defining our distance function using Euclidean Distance formula that calculates the distance between two points in our data.

Implemeting Agglomerative Clustering:
"""

distance = []
dataPoints=[]
Clusters = InitClusters 
newCluster = []
data=[]
IndexList =[]
for i in range(0,len(Data)): 
  data.append([Data[i][0],Data[i][1]])

# finding Euclidean Distance 
def EucledianDist(x, y): 
  euc_dist = (math.sqrt(pow((x[0]-y[0]),2) + pow((x[1]-y[1]),2)))
  return euc_dist

# Implementing Agglomerative Algorithm with Single Linkage 
def AggloAlgo(newCluster, data):
  for k in range(0,len(newCluster[0])):
    for i in range(0,len(data)):
      if EucledianDist(newCluster[0][k], data[i]) > 0.0:
        dataPoints.append([data[i], newCluster[0][k]])
        distance.append(EucledianDist(newCluster[0][k], data[i]))


  minSingleLinkage = min(distance)

  IndexShortestDistance = distance.index(minSingleLinkage)


  newCluster.append([dataPoints[IndexShortestDistance][0], dataPoints[IndexShortestDistance][1]]) #pairwise datapoints/cluster associated with min euclidean distance.


  for x in data:

    if dataPoints[IndexShortestDistance][0] == x:
      data.remove(dataPoints[IndexShortestDistance][0])
    elif dataPoints[IndexShortestDistance][1] == x:
      data.remove(dataPoints[IndexShortestDistance][1])


  distance.remove(minSingleLinkage)
       
  if len(data)>=1:
    AggloAlgo(newCluster, data)
  
  else: 
    print('The cluster is', newCluster)
    print(len(newCluster))


### STARTS HERE ###

for i in range(0,InitClusters):
  for j in range(i,Clusters):
    if EucledianDist(data[i], data[j]) > 0.0:
      euc_dist = EucledianDist(data[i], data[j]) #calculating pairwise eucledian distance
      dataPoints.append([data[i], data[j]])
      distance.append(euc_dist)



minSingleLinkage = min(distance)
IndexShortestDistance = distance.index(minSingleLinkage)
IndexList.append(IndexShortestDistance)

newCluster.append([dataPoints[IndexShortestDistance][0], dataPoints[IndexShortestDistance][1]]) 

data.remove(dataPoints[IndexShortestDistance][0])
data.remove(dataPoints[IndexShortestDistance][1]) #double values still in dataPoints. remove em later
  
  
distance.remove(minSingleLinkage)
  
if len(data)>0: 
    AggloAlgo(newCluster, data)
  
else: 
    print(newCluster)

"""Implementing Centroid Clustering:


This method of clustering involves using the cluster center to find distance between other points or cluster centers, and uses the minimum distance to join points and other clusters together.

In this algorithm, we use Eucledian Distance to measure the distance between two cluster centroids.

We first write a function to find the Eucledian Distance between two points.
"""

#defining Eucledian Distance function
def EucledianDist(x, y):

  #finds the distance between two given points
  euc_dist = (math.sqrt(pow((x[0]-y[0]),2) + pow((x[1]-y[1]),2)))

  #returns the distance rounded off
  return round(euc_dist,6)

"""We then write a function to find the centroid of two points."""

#defining the centroid function that finds the centroid using two given points
def Centroid (x,y):
  z = []

  #appends the average distance along the x and y axes for the two points 
  z.append((x[0]+y[0])/2)
  z.append((x[1]+y[1])/2)
  
  return(z)

"""Writing a function to perform the clustering and display the found cluster centers for n number of clusters."""

#here is where the recursive Agglomerative Clustering function begins
def AggloCentroid(data, n):

  #redefining the distance and dataPoints matrix as null for every run
  distance = []
  dataPoints = []

  #filing the distance and dataPoints matrix with relevant data
  for i in data:
    for j in data:
      #only if the Eucledian Distance is not 0.0,ie,it is not the distance between the point and itself
      if(EucledianDist(i,j) !=0.0):
        #store the distance in the matrix
        distance.append(EucledianDist(i,j))
        #store the two points in the matrix
        dataPoints.append([i,j])

  #defining leastdist as a variable to store the least distance between any two points
  leastdist = max(distance)
  #using a for loop to run through the entire matrix making sure it is the least distance
  for i in distance:
    if leastdist>i and i!=0:
      leastdist = i

  #extracting the two points between which there is least distance, naming them cp1 or cluster_point_1 and cp2
  cp1 = dataPoints[distance.index(leastdist)][0]
  cp2 = dataPoints[distance.index(leastdist)][1]

  #defining the new cluster centroid using the centroid function
  newclustercentroid = Centroid(cp1,cp2)

  #now removing the previous two points as they have been clustered
  data.remove(cp1)
  data.remove(cp2)

  #making a new list dataupdated, which does not contain the previously clustered points
  dataupdated = data

  #adding the centroid of the created cluster to the updated data to use as a new point further
  dataupdated.append(newclustercentroid)

  #now checking if the updated data has greater than n number of cluster centers
  if (len(dataupdated)>n):
    #if it does, try to make more clusters until number of clusters asked for is reached
    AggloCentroid(dataupdated, n)
  #otherwise print and show the Data and the cluster centers as asked
  else:
    #lists to plot on the x and y axis
    x = []
    y = []
    dx = []
    dy = []
    for i in Data:
      dx.append(i[0])
      dy.append(i[1])
    for i in dataupdated:
      x.append(i[0])
      y.append(i[1])
    Title = 'Displaying Centres for ' + str(n) +' Clusters'
    #Plotting the Data and cluster centers
    plt.figure(figsize=(6.5,6))
    plt.scatter(dx,dy,label='Data')
    plt.scatter(x,y,label='Cluster Centres')
    plt.xticks(range(0,101,10))
    plt.yticks(range(0,101,10))
    plt.legend()
    plt.title(Title);

#let us define some matrices

#thi stores the distance between every two points in the data set
distance = []

#the data points matrix stores the two data points used to calculate distance
dataPoints=[]

#data with a small 'd' is a current copy of the data for the recursive function
data = [] 
for i in range(0,len(Data)): 
  data.append([Data[i][0],Data[i][1],0])

#defining number of clusters to ask for
n = 3

#running the Centroid clustering on data, asking for n clusters
AggloCentroid(data,n)

"""Runs 50 points in 1s.

Runs 100 points in 2s.

Runs 300 points in 50s.

Runs 300 points in 56s.

Runs 500 points in 3m 54s.

Runs 500 points in 4m 10s.
"""